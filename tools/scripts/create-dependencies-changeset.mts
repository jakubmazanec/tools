/**
 * DO NOT EDIT!
 * This file was autogenerated by Carson.
 * Changes may cause incorrect behavior and will be lost when the file is regenerated.
 *
 * Run `npx carson update workspace` to regenerate.
 */

import {$} from 'execa';
import _ from 'lodash';
import {promises as fs} from 'node:fs';
import path from 'node:path';
import semver from 'semver';

type DependencyBumps = Map<string, string>;

async function checkCarsonTemplatesPackage(dependencyBumps: DependencyBumps) {
  // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition -- this is autogenerated
  if (false) {
    return;
  }

  let constantsFilePath = 'packages/carson-templates/source/constants.ts';
  let constantsFile = await fs.readFile(constantsFilePath, 'utf8');

  for (let [dependencyName, bump] of dependencyBumps) {
    let regexp = new RegExp(
      `(?<=('${_.escapeRegExp(dependencyName)}'|${_.escapeRegExp(dependencyName)}):\\s+')\\^\\d+\\.\\d+\\.\\d+(?='.*$)`,
      'mi',
    );
    let result = regexp.exec(constantsFile);

    if (result?.[0]) {
      let newMajorVersion = semver.major(semver.minVersion(bump)!);
      let oldMajorVersion = semver.major(semver.minVersion(result[0])!);

      if (newMajorVersion > oldMajorVersion || dependencyName === 'node') {
        // Node.js is a special case, because it isn't specified in `dependencies` field
        throw new Error(
          `Bumping major version of dependency "${dependencyName}" that is handled by Carson, update of the Carson template package is needed!`,
        );
      }
    }
  }
}

async function getProjects(files: string[]) {
  let names = [];

  for (let file of files) {
    let rawfile = await fs.readFile(file, 'utf8');
    let packageJson = JSON.parse(rawfile) as {name: string};

    names.push(packageJson.name);
  }

  return names;
}

async function createChangeset(
  fileName: string,
  dependencyBumps: DependencyBumps,
  projects: string[],
) {
  console.log('Creating changeset...');

  let message = '';

  for (let [dependencyName, bump] of dependencyBumps) {
    message += `Dependency \`${dependencyName}\` updated to version \`${bump}\`.\n`;
  }

  message = message.replace('\n', ' ');

  let header = projects.map((projectName) => `'${projectName}': patch`).join('\n');

  await fs.writeFile(fileName, `---\n${header}\n---\n${message.trim()}\n`);
}

async function createChangesetForCarsonTemplates(
  fileName: string,
  dependencyBumps: DependencyBumps,
  projects: string[],
) {
  console.log('Creating changeset for Carson templates update...');

  let message = '';

  for (let [dependencyName, bump] of dependencyBumps) {
    message += `Applies templates from \`${dependencyName}\` updated to version \`${bump}\`.\n`;
  }

  message = message.replace('\n', ' ');

  let header = projects.map((projectName) => `'${projectName}': patch`).join('\n');

  await fs.writeFile(fileName, `---\n${header}\n---\n${message.trim()}\n`);
}

async function getBumps(files: string[]) {
  let bumps = new Map<string, string>();

  for (let file of files) {
    let {stdout: changes} = await $`git show ${file}`;

    for (let change of changes.split('\n')) {
      if (!change.startsWith('+ ')) {
        continue;
      }

      let match = change.match(/"(.*?)"/g);

      if (match?.[0] && match[1]) {
        bumps.set(match[0].replaceAll('"', ''), match[1].replaceAll('"', ''));
      }
    }
  }

  return bumps;
}

async function getProjectsWithCarsonTemplates(dir = process.cwd(), result: string[] = []) {
  let entries = await fs.readdir(dir, {withFileTypes: true});

  for (let entry of entries) {
    let fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (entry.name === '.carson' && dir !== process.cwd()) {
        let packageJson = JSON.parse(await fs.readFile(path.join(dir, 'package.json'), 'utf8')) as {
          name: string;
        };

        result.push(packageJson.name);
      } else {
        await getProjectsWithCarsonTemplates(fullPath, result);
      }
    }
  }

  return result;
}

let {stdout: diffOutput} = await $`git diff --name-only HEAD~1`;
let diffFiles = diffOutput.split('\n');

if (diffFiles.find((diffFile) => diffFile.startsWith('.changeset'))) {
  throw new Error('Changeset already exists!');
}

let files = diffFiles
  .filter((file) => file !== 'package.json') // skip workspace package.json
  .filter((file) => file.endsWith('package.json'));
let filesWithWorkspace = diffFiles.filter((file) => file.endsWith('package.json'));
let {stdout: shortHash} = await $`git rev-parse --short HEAD`;
let changesetName = `.changeset/renovate-${shortHash.trim()}.md`;
let updatedProjects = await getProjects(files);
let dependencyBumpsWithWorkspace = await getBumps(filesWithWorkspace);

console.log('Changed package.json files:', files);

if (dependencyBumpsWithWorkspace.has('@jakubmazanec/carson-templates')) {
  updatedProjects = await getProjectsWithCarsonTemplates();

  console.log('Updated projects:', updatedProjects);
  console.log('Dependecy bumps (including the workspace):', [...dependencyBumpsWithWorkspace]);

  await createChangesetForCarsonTemplates(
    changesetName,
    dependencyBumpsWithWorkspace,
    updatedProjects,
  );
} else if (updatedProjects.length) {
  let dependencyBumps = await getBumps(files);

  console.log('Updated projects:', updatedProjects);
  console.log('Dependecy bumps:', [...dependencyBumps]);

  await createChangeset(changesetName, dependencyBumps, updatedProjects);

  await checkCarsonTemplatesPackage(dependencyBumpsWithWorkspace);
} else {
  console.log('No package.json changes to published packages, creating empty changeset...');

  await fs.writeFile(changesetName, '---\n---\n');
}
