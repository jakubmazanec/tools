---
to: 'tools/scripts/create-dependencies-changeset.mts'
strategy: overwrite
---
/**
 * DO NOT EDIT!
 * This file was autogenerated by Carson.
 * Changes may cause incorrect behavior and will be lost when the file is regenerated.
 *
 * Run `npx carson update workspace` to regenerate.
 */

import {$} from 'execa';
import _ from 'lodash';
import {promises as fs} from 'node:fs';
import path from 'node:path';
import semver from 'semver';

const WORKSPACE_PLACEHOLDER_NAME = '@';
const WORKSPACE_PACKAGE_JSON_PATH = 'package.json';
const TEMPLATE_PACKAGE_NAME = '<%- TEMPLATE_PACKAGE_NAME %>';

type ProjectDependencyBumps = Map<string, string>;
type DependencyBumps = Map<string, ProjectDependencyBumps>;

/**
 * A function that returns all projects that use Carson.
 */
async function getProjectsWithCarson(dir = process.cwd(), result: string[] = []) {
  let entries = await fs.readdir(dir, {withFileTypes: true});

  for (let entry of entries) {
    let fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (entry.name === '.carson' && dir !== process.cwd()) {
        let packageJson = JSON.parse(await fs.readFile(path.join(dir, 'package.json'), 'utf8')) as {
          name: string;
        };

        result.push(packageJson.name);
      } else {
        await getProjectsWithCarson(fullPath, result);
      }
    }
  }

  return result;
}

/**
 * A function that checks if one of the updated dependencies was a major version bump that necessitates manual update of the Carson template package.
 */
async function checkCarsonTemplatesPackage(dependencyBumps: DependencyBumps) {
  // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition -- this is autogenerated
  if (<%- !workspace.projects.some((project) => project.name === TEMPLATE_PACKAGE_NAME) %>) {
    return;
  }

  let constantsFilePath = '<%- `${workspace.projects.find((project) => project.name === TEMPLATE_PACKAGE_NAME)?.relativePath ?? ''}/source/constants.ts` %>';
  let constantsFile = await fs.readFile(constantsFilePath, 'utf8');

  for (let [, projectDependencyBumps] of dependencyBumps) {
    if (!projectDependencyBumps.size) {
      continue;
    }

    for (let [dependencyName, bump] of projectDependencyBumps) {
      let regexp = new RegExp(
        `(?<=('${_.escapeRegExp(dependencyName)}'|${_.escapeRegExp(dependencyName)}):\\s+')\\^\\d+\\.\\d+\\.\\d+(?='.*$)`,
        'mi',
      );
      let result = regexp.exec(constantsFile);

      if (result?.[0]) {
        let newMajorVersion = semver.major(semver.minVersion(bump)!);
        let oldMajorVersion = semver.major(semver.minVersion(result[0])!);

        // Node.js is a special case, because it isn't specified in `dependencies` field
        if (newMajorVersion > oldMajorVersion || dependencyName === 'node') {
          throw new Error(
            `Bumping major version of dependency "${dependencyName}" that is handled by Carson, update of the Carson template package is needed!`,
          );
        }
      }
    }
  }
}

/**
 * A function that creates changesets for projects dependencies update.
 */
async function createChangeset(
  getChangesetName: (suffix?: string) => string,
  dependencyBumps: DependencyBumps,
) {
  for (let [projectName, projectDependencyBumps] of dependencyBumps) {
    if (!projectDependencyBumps.size) {
      continue;
    }

    if (projectName !== WORKSPACE_PLACEHOLDER_NAME) {
      console.log('Creating changeset for project:', projectName);

      let message = '';

      for (let [dependencyName, dependencyBump] of projectDependencyBumps) {
        message += `Dependency \`${dependencyName}\` updated to version \`${dependencyBump}\`.\n`;
      }

      message = message.replaceAll('\n', ' ');

      await fs.writeFile(
        getChangesetName(projectName),
        `---\n'${projectName}': patch\n---\n${message.trim()}\n`,
      );
    }
  }
}

/**
 * A function that creates changeset when updating the Carson template package.
 */
async function createChangesetForCarsonTemplates(
  getChangesetName: (suffix?: string) => string,
  dependencyBumps: DependencyBumps,
) {
  console.log('Creating changeset for Carson templates update...');

  let workspaceDependencyBumps = dependencyBumps.get(WORKSPACE_PLACEHOLDER_NAME);

  if (workspaceDependencyBumps) {
    let message = `Applies templates from \`${TEMPLATE_PACKAGE_NAME}\` updated to version \`${workspaceDependencyBumps.get(TEMPLATE_PACKAGE_NAME) ?? '?'}\`.\n`;

    let projects = await getProjectsWithCarson();
    let header = projects.map((projectName) => `'${projectName}': patch`).join('\n');

    await fs.writeFile(getChangesetName(), `---\n${header}\n---\n${message.trim()}\n`);
  }
}

/**
 * A function that returns workspace and projects and their updated dependencies. based on `git diff`.
 */
async function getDependencyBumps(files: string[]): Promise<DependencyBumps> {
  let bumps: DependencyBumps = new Map();

  for (let file of files) {
    let projectBumps: ProjectDependencyBumps = new Map();
    let {stdout: changes} = await $`git diff HEAD~1 -- ${file}`;

    for (let change of changes.split('\n')) {
      if (!change.startsWith('+ ')) {
        continue;
      }

      let match = change.match(/"(.*?)"/g);

      if (match?.[0] && match[1] && semver.validRange(match[1].replaceAll('"', ''))) {
        projectBumps.set(match[0].replaceAll('"', ''), match[1].replaceAll('"', ''));
      }
    }

    if (file === WORKSPACE_PACKAGE_JSON_PATH && projectBumps.size) {
      bumps.set(WORKSPACE_PLACEHOLDER_NAME, projectBumps);
    } else if (projectBumps.size) {
      let projectName = (JSON.parse(await fs.readFile(file, 'utf8')) as {name: string}).name;

      bumps.set(projectName, projectBumps);
    }
  }

  return bumps;
}

let {stdout: diffOutput} = await $`git diff --name-only HEAD~1`;
let diffLines = diffOutput.split('\n');

if (diffLines.some((diffLine) => diffLine.startsWith('.changeset'))) {
  console.log('Changeset already exists!');
} else {
  let files = diffLines.filter((file) => file.endsWith('package.json'));
  let {stdout: shortHash} = await $`git rev-parse --short HEAD`;
  let getChangesetName = (suffix?: string) =>
    suffix === undefined ?
      `.changeset/dependencies-update-${shortHash.trim()}.md`
    : `.changeset/dependencies-update-${shortHash.trim()}-${suffix.replaceAll('/', '-')}.md`;

  let dependencyBumps = await getDependencyBumps(files);

  console.log('Dependecy bumps:', dependencyBumps);

  if (dependencyBumps.get(WORKSPACE_PLACEHOLDER_NAME)?.has(TEMPLATE_PACKAGE_NAME)) {
    await createChangesetForCarsonTemplates(getChangesetName, dependencyBumps);
  } else if (
    dependencyBumps.size === 0 ||
    (dependencyBumps.size === 1 && dependencyBumps.has(WORKSPACE_PLACEHOLDER_NAME))
  ) {
    console.log('No package.json changes to projects, creating empty changeset...');

    await fs.writeFile(getChangesetName(), '---\n---\n');
    await checkCarsonTemplatesPackage(dependencyBumps);
  } else {
    await createChangeset(getChangesetName, dependencyBumps);
    await checkCarsonTemplatesPackage(dependencyBumps);
  }
}

console.log('Done!');
