---
to: 'tools/scripts/create-templates-changeset.mts'
if: <%- workspace.projects.some((project) => project.name === TEMPLATE_PACKAGE_NAME) %>
strategy: overwrite
---
/**
 * DO NOT EDIT!
 * This file was autogenerated by Carson.
 * Changes may cause incorrect behavior and will be lost when the file is regenerated.
 *
 * Run `npx carson update workspace` to regenerate.
 */

import {$} from 'execa';
import _ from 'lodash';
import {promises as fs} from 'node:fs';
import semver from 'semver';

const WORKSPACE_PLACEHOLDER_NAME = '@';
const WORKSPACE_PACKAGE_JSON_PATH = 'package.json';
const TEMPLATE_PACKAGE_NAME = '<%- TEMPLATE_PACKAGE_NAME %>';

type ProjectDependencyBumps = Map<string, string>;
type DependencyBumps = Map<string, ProjectDependencyBumps>;

/**
 * A function that checks if one of the updated dependencies was a major version bump that necessitates manual update of the Carson template package.
 */
async function checkCarsonTemplatesPackage(
  getChangesetName: (suffix?: string) => string,
  dependencyBumps: DependencyBumps,
) {
  let constantsFilePath = '<%- `${workspace.projects.find((project) => project.name === TEMPLATE_PACKAGE_NAME)?.relativePath ?? ''}/source/constants.ts` %>';
  let constantsFile = await fs.readFile(constantsFilePath, 'utf8');
  let templatesBump: ProjectDependencyBumps = new Map();

  for (let [, projectDependencyBumps] of dependencyBumps) {
    if (!projectDependencyBumps.size) {
      continue;
    }

    for (let [dependencyName, bump] of projectDependencyBumps) {
      let regexp = new RegExp(
        `(?<=('${_.escapeRegExp(dependencyName)}'|${_.escapeRegExp(dependencyName)}):\\s+')\\^\\d+\\.\\d+\\.\\d+(?='.*$)`,
        'mi',
      );
      let result = regexp.exec(constantsFile);

      if (result?.[0]) {
        let newMajorVersion = semver.major(semver.minVersion(bump)!);

        templatesBump.set(dependencyName, `${newMajorVersion}`);
      }
    }
  }

  if (templatesBump.size) {
    console.log('Creating changeset for project:', TEMPLATE_PACKAGE_NAME);

    let message = '';

    for (let [dependencyName, dependencyBump] of templatesBump) {
      message += `Templates were updated to use \`${dependencyName}\` v${dependencyBump}.\n`;
    }

    message = message.replaceAll('\n', ' ');

    await fs.writeFile(
      getChangesetName(),
      `---\n'${TEMPLATE_PACKAGE_NAME}': major\n---\n${message.trim()}\n`,
    );
  }
}

/**
 * A function that returns workspace and projects and their updated dependencies. based on `git diff`.
 */
async function getDependencyBumps(files: string[]): Promise<DependencyBumps> {
  let bumps: DependencyBumps = new Map();

  for (let file of files) {
    let projectBumps: ProjectDependencyBumps = new Map();
    let {stdout: changes} = await $`git diff HEAD~1 -- ${file}`;

    for (let change of changes.split('\n')) {
      if (!change.startsWith('+ ')) {
        continue;
      }

      let match = change.match(/"(.*?)"/g);

      if (match?.[0] && match[1] && semver.validRange(match[1].replaceAll('"', ''))) {
        projectBumps.set(match[0].replaceAll('"', ''), match[1].replaceAll('"', ''));
      }
    }

    if (file === WORKSPACE_PACKAGE_JSON_PATH && projectBumps.size) {
      bumps.set(WORKSPACE_PLACEHOLDER_NAME, projectBumps);
    } else if (projectBumps.size) {
      let projectName = (JSON.parse(await fs.readFile(file, 'utf8')) as {name: string}).name;

      bumps.set(projectName, projectBumps);
    }
  }

  return bumps;
}

let {stdout: diff} = await $`git diff --name-only HEAD~1`;
let files = diff.split('\n').filter((file) => file.endsWith('package.json'));
let {stdout: shortHash} = await $`git rev-parse --short HEAD`;
let getChangesetName = (suffix?: string) =>
  suffix === undefined ?
    `.changeset/templates-update-${shortHash.trim()}.md`
  : `.changeset/templates-update-${shortHash.trim()}-${suffix.replaceAll('/', '-')}.md`;

let dependencyBumps = await getDependencyBumps(files);

console.log('Dependecy bumps:', dependencyBumps);

await checkCarsonTemplatesPackage(getChangesetName, dependencyBumps);

console.log('Done!');
